<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 并发 - 理论基础 | 墨文博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/Merven_Blog/destfavicon.ico">
    <meta name="description" content="欢迎来到墨文的博客">
    
    <link rel="preload" href="/Merven_Blog/dest/assets/css/0.styles.d5f538a7.css" as="style"><link rel="preload" href="/Merven_Blog/dest/assets/js/app.6a730868.js" as="script"><link rel="preload" href="/Merven_Blog/dest/assets/js/2.a712d209.js" as="script"><link rel="preload" href="/Merven_Blog/dest/assets/js/1.bcdbbaef.js" as="script"><link rel="preload" href="/Merven_Blog/dest/assets/js/25.367530aa.js" as="script"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/10.3624c371.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/11.009a4088.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/12.50f662a6.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/13.7eaaa4cc.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/14.6fbdd8d3.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/15.fd694769.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/16.d211645d.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/17.485728d4.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/18.f646c752.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/19.5e8d1a39.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/20.4b4a7f9d.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/21.8ee70ab5.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/22.94294803.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/23.38f31caf.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/24.c2cc382b.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/26.19eda6c2.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/27.17c792cb.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/28.5423fdf7.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/29.0001b6ca.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/3.ce2fe7f0.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/30.84e3d268.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/31.c880da57.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/32.f4c266e8.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/4.ace105ca.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/5.e8df22f9.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/6.84614bbb.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/7.58f38b18.js"><link rel="prefetch" href="/Merven_Blog/dest/assets/js/vendors~docsearch.6dc52818.js">
    <link rel="stylesheet" href="/Merven_Blog/dest/assets/css/0.styles.d5f538a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Merven_Blog/dest/" class="home-link router-link-active"><!----> <span class="site-name">墨文博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Merven_Blog/dest/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/JVM/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/development/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/notes/" class="nav-link">
  工具
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Languages" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Merven_Blog/dest/language/chinese.html" class="nav-link">
  中文
</a></li><li class="dropdown-item"><!----> <a href="/Merven_Blog/dest/language/English.html" class="nav-link">
  English
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Merven_Blog/dest/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/JVM/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/development/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/Merven_Blog/dest/notes/" class="nav-link">
  工具
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow down"></span></button> <button type="button" aria-label="Languages" class="mobile-dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Merven_Blog/dest/language/chinese.html" class="nav-link">
  中文
</a></li><li class="dropdown-item"><!----> <a href="/Merven_Blog/dest/language/English.html" class="nav-link">
  English
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/Merven_Blog/dest/blog/hello-vuepress" class="sidebar-heading clickable"><span>vue-press教程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Merven_Blog/dest/blog/hello-vuepress.html" class="sidebar-link">Hello VuePress</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Merven_Blog/dest/javaBase/JavaBase" class="sidebar-heading clickable"><span>基础学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Merven_Blog/dest/javaBase/JavaBase.html" class="sidebar-link">Java基础</a></li><li><a href="/Merven_Blog/dest/javaBase/Annotation.html" class="sidebar-link">注解详解</a></li><li><a href="/Merven_Blog/dest/javaBase/Paradigm.html" class="sidebar-link">范型详解</a></li><li><a href="/Merven_Blog/dest/javaBase/HashMap.html" class="sidebar-link">Map源码分析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Merven_Blog/dest/oop/solid" class="sidebar-heading clickable"><span>面向对象</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Merven_Blog/dest/oop/solid.html" class="sidebar-link">solid原则</a></li><li><a href="/Merven_Blog/dest/oop/uml.html" class="sidebar-link">uml</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Merven_Blog/dest/javaAdvance/thread-theory" class="sidebar-heading clickable open active"><span>进阶</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Merven_Blog/dest/javaAdvance/thread-theory.html" aria-current="page" class="active sidebar-link">理论基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Merven_Blog/dest/javaAdvance/thread-theory.html#为什么需要多线程" class="sidebar-link">为什么需要多线程</a></li><li class="sidebar-sub-header"><a href="/Merven_Blog/dest/javaAdvance/thread-theory.html#线程不安全示例" class="sidebar-link">线程不安全示例</a></li><li class="sidebar-sub-header"><a href="/Merven_Blog/dest/javaAdvance/thread-theory.html#java是怎么解决并发问题的-jmm-java内存模型" class="sidebar-link">JAVA是怎么解决并发问题的: JMM(Java内存模型)</a></li></ul></li><li><a href="/Merven_Blog/dest/javaAdvance/thread-key-volatile.html" class="sidebar-link">Volatile关键字</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/Merven_Blog/dest/tool/git-add-socket" class="sidebar-heading clickable"><span>工具</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/Merven_Blog/dest/tool/git-add-socket.html" class="sidebar-link">git使用 socket 代理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java-并发-理论基础"><a href="#java-并发-理论基础" class="header-anchor">#</a> Java 并发 - 理论基础</h1> <p>本文从理论的角度引入并发安全问题以及JMM应对并发问题的原理。</p> <h2 id="为什么需要多线程"><a href="#为什么需要多线程" class="header-anchor">#</a> 为什么需要多线程</h2> <p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p> <ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题</li> <li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题</li> <li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题</li></ul> <hr> <h2 id="线程不安全示例"><a href="#线程不安全示例" class="header-anchor">#</a> 线程不安全示例</h2> <p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。
以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadUnsafeExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">&gt;&gt;</span> <span class="token number">997</span> <span class="token comment">// 结果总是小于1000</span>
</code></pre></div><h3 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="header-anchor">#</a> 并发出现问题的根源: 并发三要素</h3> <blockquote><p>上述代码输出为什么不是1000? 并发出现问题的根源是什么?</p> <ul><li>可见性: CPU缓存引起</li> <li>原子性: 分时复用引起</li> <li>有序性: 重排序引起</li></ul></blockquote> <h4 id="可见性-cpu缓存引起"><a href="#可见性-cpu缓存引起" class="header-anchor">#</a> 可见性: CPU缓存引起</h4> <p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//线程1执行的代码</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
 
<span class="token comment">//线程2执行的代码</span>
j <span class="token operator">=</span> i<span class="token punctuation">;</span>
</code></pre></div><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p> <p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p> <p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p> <h4 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="header-anchor">#</a> 原子性: 分时复用引起</h4> <p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 线程1执行</span>
i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 线程2执行</span>
i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>这里需要注意的是：<code>i += 1</code>需要三条 CPU 指令</p> <ol><li>将变量 i 从内存读取到 CPU寄存器；</li> <li>在CPU寄存器中执行 i + 1 操作；</li> <li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ol> <p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p> <h4 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="header-anchor">#</a> 有序性: 重排序引起</h4> <p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              
<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//语句1  </span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token comment">//语句2</span>
</code></pre></div><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p> <p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p> <ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li> <li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li> <li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul> <p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhEAAABMCAMAAADkzxUgAAAANlBMVEX///8AAADjbAoBzP9/f4C1tLQ6Ojrv7+AhFRXD/v8zAHTaiktkr/FtaHL/35ygSgH/v3QAbroF0XLpAAAGEUlEQVR4nO1d6XrbMAwjsubokq7t+7/sEscHSUnW5abpBuxHcziERMKgZPv7JkIQBEEQBEEQBEEQBEEQBEEQBEEQPx0HdOKQIfi1LTJs593GOMvjGM9fVqSaqkE6kQuQq2EdctF2sjF23QdswNVdpJqIVERnQCqiNgAV0c9FRbRHoyLKQEU0g4rYMvYAKqKf67sUcX057k2W9+P3w4fqq7LYA7oUAR+/SRFBFPhX+g/yAYsOQPLNmM+2UKZEwzd2NljeLEciM54kmc0dVC6RjNSiCLiQauiT9MIhJKMlkroDLiaKzpVPm+FLBMwynmdGPT9RlwGmd9lQkXyZ10bCevh6avF8BxFXyOYE6fAwMbsU8fH71dAsRDAUhtXKu1wRHxf5GAo0icyk0ZnCnFn4glUo4s9lnmEQKSgHVkOt5DjI3JI7PUl9ZkccvkgRGP+Zcmjb6VXEB6Z8eedR7UkrArNyEEbL1Wd4dzF8UFRqQpC4B0cC5hiPb68mEHRRAPU6P/hEjnXmhkqb8euCGWeK9Jc82T289m9o5+v3iD93RajBymTms++prjHNAvFo+frI+VXeP21fwlwsjLMaJi2mkMmAOcbzbYJXSqeIUP8Fg4/mGM7IbD8w+bIGjKIR+K+0R8Bp3CxUUgFi8Ip4/7wrW7Mu1VGTEOlVxPFlHn1i0IjxpQNmGI8nfCoXRNCcJEmzzuU8wlkrdJnUZkAf3ugREltHKOpoqHqPcJsaZ4OAXyI3K+L8OsYU3UVtfKjTqHMdcZvhSfcpVRzAmW/vXmMKJcr57hOd9AeT60BKUkAGq2X3ZhzHBoqA7X+wHUrT9inifFmG6E/LpQ8LrNy7usaycoFOqPd2SNc6wg3Trl9tItXh9YrAZEGuNLMa46EaFOE9Qq1m7bK4SxHXzYbszcLFTHQePmTDleW811gCSnBy2eIUcLnWDtsnwtDWeyHWiH3ENBmc1y0Z27hrCER7hPZU24AR5K9cEedbxMu8sozmA0Aw43ZFXBl/q5WlChb6XjRvhSvL5ay1q3JRGRUJuoa0dA0jwLntih7PWoAo9O7zlrHbylJc1zD5MopYHM9Hy9XHDtp1buMRE4fPWipgwQGqKU2zAtxLlIWKHArYsiiDVe8h6goFXPHKFNGGCo9Qv3HiVvrT1yzhMsv7Glvh2RTRDipiG3yHIvbj3wcpYqR7nCKO2zOGofbH4c+/oYjD6X596EGKwGGo0OMUsd+eMQz1grebJv4RRQCDJh6lCAwV2pmRBXcTgMSVjmQaVhQRYxSzkalkjCkCN03UFKlsM/iFijjiJY7TLRlXTWysiH2Cbsj9YR/UJzFXXZ/otcoJ7wm+l7c4o7sdVMW4CyZ3fyz/LXKFKjYrfdXVbOhDfKlHrCvi+GttNtVYV8RJ18cwwRRBpU0yQ9pVKMLcPGhgrFBE4mGPsLT4BkUkPh+6xtH6PHo8dcBa1zgZD18ujGbP2JUb1DVdY9n9SxtjQddYZGUSJyas3rQ/kyIGPZga+tOjwcXTijgF6zwYEhvS3CWUZOIqV5aQiEuUMxatLCH2wp4mFLFXl59LEePGKaYItLt4xe7TXYOEtqiRS/GlSGt2n8tU2hiLdp96rWIe9ghOgWdTxISlhsuNi/CnpS5efoUKKx6B8pVlxRUqOJuuZiy8G578FroXQ/DsinCPRLW5eM01yxWPkMCTkJhJ9TVLtDOW3emSxMMeasLQfvzEHqH8TVpdvFkRKyvZtq4RZVzOzRbGxucjtATNNz9CEebJzQYXb/cISXWp4LBkwMwB5nZ+C2OxIqy5IjFhSIJHnkcRbvgNLl6pCL0TsytZMfVJrFqktmvo6PWMbR6RUgAiP45GLP+qDLVdY5pVm4v/7/c+sfKwx6R99+lPUYT7aamL8274NngiRehHKRtcnIrYBk+iiA1ARWwDKqIZVMSWsQdQEf1cVER7NCqiDFREM6iILWMPoCL6uaiI9mhURBmoiGZQEVvGHkBF9HNREe3RqIgyUBHN+P8UcUInThnux/5vCrvNkcvtI7i6i1RdNYIgCIIgCIIgCIIgCIIgCIIgCIIgCIL48fgLDHYYvg1OrDgAAAAASUVORK5CYII=" alt="img"></p> <p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p> <hr> <h2 id="java是怎么解决并发问题的-jmm-java内存模型"><a href="#java是怎么解决并发问题的-jmm-java内存模型" class="header-anchor">#</a> JAVA是怎么解决并发问题的: JMM(Java内存模型)</h2> <h3 id="理解的第一个维度-核心知识点"><a href="#理解的第一个维度-核心知识点" class="header-anchor">#</a> <strong>理解的第一个维度：核心知识点</strong></h3> <p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p> <ul><li>volatile、synchronized 和 final 三个关键字</li> <li>Happens-Before 规则</li></ul> <h3 id="理解的第二个维度-可见性-有序性-原子性"><a href="#理解的第二个维度-可见性-有序性-原子性" class="header-anchor">#</a> <strong>理解的第二个维度：可见性，有序性，原子性</strong></h3> <p><em><strong>原子性</strong></em></p> <p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：</p> <div class="language-ja extra-class"><pre class="language-text"><code>x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x = x + 1;     //语句4： 同语句3
</code></pre></div><p>上面4个语句只有语句1的操作具备原子性。</p> <p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p> <blockquote><p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote> <p><em><strong>可见性</strong></em></p> <p>Java提供了volatile关键字来保证可见性。</p> <p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p> <p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p> <blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote> <p><em><strong>有序性</strong></em></p> <p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p> <h3 id="关键字-volatile、synchronized"><a href="#关键字-volatile、synchronized" class="header-anchor">#</a> 关键字: volatile、synchronized</h3> <ul><li><a href="">关键字: volatile详解</a></li> <li>关键字: synchronized详解</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Merven_Blog/dest/oop/uml.html" class="prev">
        uml
      </a></span> <span class="next"><a href="/Merven_Blog/dest/javaAdvance/thread-key-volatile.html">
        Volatile关键字
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Merven_Blog/dest/assets/js/app.6a730868.js" defer></script><script src="/Merven_Blog/dest/assets/js/2.a712d209.js" defer></script><script src="/Merven_Blog/dest/assets/js/1.bcdbbaef.js" defer></script><script src="/Merven_Blog/dest/assets/js/25.367530aa.js" defer></script>
  </body>
</html>
